import os
import requests
import shlex, subprocess

SENTINEL_URL = os.getenv("SENTINEL_API_URL") or os.getenv("SENTINEL_URL") or "http://127.0.0.1:8001/analyze"

SANDBOX_DIR = os.path.expanduser("~/sentinel/sandbox")

# only allow these commands (you can add more later)
ALLOW_CMDS = {"ls", "pwd", "echo", "cat", "whoami", "date"}

def run_in_sandbox(cmd: str) -> str:
    cmd = (cmd or "").strip()
    if not cmd:
        return "Empty command."

    parts = shlex.split(cmd)
    base = parts[0]

    if base not in ALLOW_CMDS:
        return f"Blocked: '{base}' not in allowlist."

    # extra safety: block obvious dangerous tokens even inside allowed commands
    bad_tokens = {"|", ";", "&&", "||", ">", ">>", "<", "`", "$(", "${"}
    if any(tok in cmd for tok in bad_tokens):
        return "Blocked: shell operators are not allowed."

    try:
        r = subprocess.run(
            parts,
            cwd=SANDBOX_DIR,
            capture_output=True,
            text=True,
            timeout=3,
            check=False,
        )
        out = (r.stdout or "") + (("\n" + r.stderr) if r.stderr else "")
        out = out.strip()
        return out if out else "(no output)"
    except subprocess.TimeoutExpired:
        return "Timed out."
    except Exception as e:
        return f"Exec error: {e}"
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters

BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")
ALLOWED_CHAT = os.getenv("TELEGRAM_ALLOWED_CHAT", "").strip()

def allowed(update: Update) -> bool:
    if not ALLOWED_CHAT:
        return True
    return str(update.effective_chat.id) == ALLOWED_CHAT

def call_sentinel(command: str, agent_id: str) -> dict:
    import time, json, hmac, hashlib

    url = os.getenv("SENTINEL_API_URL") or os.getenv("SENTINEL_URL") or "http://127.0.0.1:8001/analyze"
    api_key = os.getenv("SENTINEL_API_KEY", "")
    secret = os.getenv("SENTINEL_SIGNING_SECRET", "")

    ts = str(int(time.time()))

    body = {"agent_id": agent_id, "command": command, "timestamp": ts}
    body_json = json.dumps(body, separators=(",",":"), sort_keys=True)

    signed_payload = {"agent_id": agent_id, "command": command, "timestamp": ts, "ts_unix": ts}
    msg = json.dumps(signed_payload, separators=(",",":"), sort_keys=True).encode()
    sig = hmac.new(secret.encode(), msg, hashlib.sha256).hexdigest()

    headers = {
        "Content-Type": "application/json",
        "X-API-Key": api_key,
        "X-Timestamp-Unix": ts,
        "X-Signature": sig,
    }

    r = requests.post(url, data=body_json, headers=headers, timeout=10)
    r.raise_for_status()
    return r.json()

def call_status(agent_id: str) -> dict:
    import time, json, hmac, hashlib

    url_base = os.getenv("SENTINEL_API_URL") or os.getenv("SENTINEL_URL") or "http://127.0.0.1:8001/analyze"
    # status endpoint is /api/v1/status/{agent_id}
    status_url = url_base.replace("/analyze", f"/api/v1/status/{agent_id}")

    api_key = os.getenv("SENTINEL_API_KEY", "")
    secret = os.getenv("SENTINEL_SIGNING_SECRET", "")

    ts = str(int(time.time()))

    signed_payload = {"agent_id": agent_id, "ts_unix": ts}
    msg = json.dumps(signed_payload, separators=(",", ":"), sort_keys=True).encode()
    sig = hmac.new(secret.encode(), msg, hashlib.sha256).hexdigest()

    headers = {
        "X-API-Key": api_key,
        "X-Timestamp-Unix": ts,
        "X-Signature": sig,
    }

    r = requests.get(status_url, headers=headers, timeout=10)
    r.raise_for_status()
    return r.json()

async def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not allowed(update):
        return

    try:
        agent_id = f"tg:{update.effective_user.id}"
        s = call_status(agent_id)

        rep = s.get("reputation", {})
        rl = s.get("rate_limit", {})
        m = s.get("metrics", {})

        msg = "\n".join([
            "üßæ /status",
            f"Agent: {s.get('agent_id')}",
            f"Policy: {s.get('policy_version')}",
            f"Server time (unix): {s.get('server_time_unix')}",
            "",
            f"Reputation: {rep.get('reputation')} | allowed={rep.get('allowed')} blocked={rep.get('blocked')} reviewed={rep.get('reviewed')}",
            f"Rate limit: remaining={rl.get('remaining')}/{rl.get('max')} in {rl.get('window_sec')}s",
            "",
            f"Metrics: ok={m.get('requests_ok')} 401={m.get('http_401_total')} 409={m.get('http_409_total')} 429={m.get('http_429_total')}",
        ])

        await update.message.reply_text(msg)
    except Exception as e:
        await update.message.reply_text(f"/status error: {e}")

def fmt(d: dict) -> str:
    decision = d.get("decision", "UNKNOWN")
    risk = d.get("risk", "UNKNOWN")
    reason = d.get("reason", "")
    vt = d.get("vt") or d.get("variable_timestamp") or ""
    policy = d.get("policy_version", "")
    sig = d.get("signature", "")

    out = [
        "üõ°Ô∏è Sentinel SCA",
        f"Decision: {decision}",
        f"Risk: {risk}",
    ]

    if reason:
        out.append(f"Reason: {reason}")

    if policy:
        out.append(f"Policy: {policy}")

    if vt:
        out.append(f"VT: {vt}")

    if sig:
        out.append(f"Signature: {sig}")

    return "\n".join(out)


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not allowed(update):
        return

    cmd = (update.message.text or "").strip()


    try:
        agent_id = f"tg:{update.effective_user.id}"
        result = call_sentinel(cmd, agent_id)

        # If Sentinel denied, just return formatted result
        if result.get("decision") != "allow":
            await update.message.reply_text(fmt(result))
            return

        # If allowed, execute safely in sandbox
        output = run_in_sandbox(cmd)

        reply = fmt(result) + "\n\n--- Command Output ---\n" + output
        await update.message.reply_text(reply)

    except Exception as e:
        await update.message.reply_text(f"Error: {e}")


def main():
    app = Application.builder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("status", status_cmd))

    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("ü§ñ Telegram bot running...")
    app.run_polling()


if __name__ == "__main__":
    main()
